// Code generated by sqlc. DO NOT EDIT.
// source: purchases.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/tabbed/pqtype"
)

const createPurchase = `-- name: CreatePurchase :one
INSERT INTO purchases (
    owner_id, 
    user_id, 
    "number", 
    ap_id, 
    status, 
    amount, 
    amount_paid, 
    "date", 
    due_date, 
    additional_info, 
    period_id, 
    expense_id, 
    discount_id,
    created_by,
    updated_by
) 
VALUES(
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15
) RETURNING id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type CreatePurchaseParams struct {
	OwnerID        int32                 `json:"owner_id"`
	UserID         int32                 `json:"user_id"`
	Number         string                `json:"number"`
	ApID           int32                 `json:"ap_id"`
	Status         int16                 `json:"status"`
	Amount         string                `json:"amount"`
	AmountPaid     string                `json:"amount_paid"`
	Date           time.Time             `json:"date"`
	DueDate        time.Time             `json:"due_date"`
	AdditionalInfo pqtype.NullRawMessage `json:"additional_info"`
	PeriodID       sql.NullInt32         `json:"period_id"`
	ExpenseID      sql.NullInt32         `json:"expense_id"`
	DiscountID     sql.NullInt32         `json:"discount_id"`
	CreatedBy      int32                 `json:"created_by"`
	UpdatedBy      int32                 `json:"updated_by"`
}

func (q *Queries) CreatePurchase(ctx context.Context, arg CreatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, createPurchase,
		arg.OwnerID,
		arg.UserID,
		arg.Number,
		arg.ApID,
		arg.Status,
		arg.Amount,
		arg.AmountPaid,
		arg.Date,
		arg.DueDate,
		arg.AdditionalInfo,
		arg.PeriodID,
		arg.ExpenseID,
		arg.DiscountID,
		arg.CreatedBy,
		arg.UpdatedBy,
	)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.UserID,
		&i.Number,
		&i.ApID,
		&i.Status,
		&i.Amount,
		&i.AmountPaid,
		&i.Date,
		&i.DueDate,
		&i.AdditionalInfo,
		&i.PeriodID,
		&i.ExpenseID,
		&i.DiscountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const deletePurchase = `-- name: DeletePurchase :exec
UPDATE purchases
SET deleted_at=now(),
    deleted_by=$2
WHERE id = $1
RETURNING id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type DeletePurchaseParams struct {
	ID        int32         `json:"id"`
	DeletedBy sql.NullInt32 `json:"deleted_by"`
}

func (q *Queries) DeletePurchase(ctx context.Context, arg DeletePurchaseParams) error {
	_, err := q.db.ExecContext(ctx, deletePurchase, arg.ID, arg.DeletedBy)
	return err
}

const getPurchase = `-- name: GetPurchase :one
SELECT id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by FROM purchases
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPurchase(ctx context.Context, id int32) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, getPurchase, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.UserID,
		&i.Number,
		&i.ApID,
		&i.Status,
		&i.Amount,
		&i.AmountPaid,
		&i.Date,
		&i.DueDate,
		&i.AdditionalInfo,
		&i.PeriodID,
		&i.ExpenseID,
		&i.DiscountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const getPurchaseForUpdate = `-- name: GetPurchaseForUpdate :one
SELECT id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by FROM purchases
WHERE id = $1 LIMIT 1
FOR NO KEY UPDATE
`

func (q *Queries) GetPurchaseForUpdate(ctx context.Context, id int32) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, getPurchaseForUpdate, id)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.UserID,
		&i.Number,
		&i.ApID,
		&i.Status,
		&i.Amount,
		&i.AmountPaid,
		&i.Date,
		&i.DueDate,
		&i.AdditionalInfo,
		&i.PeriodID,
		&i.ExpenseID,
		&i.DiscountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}

const listPurchases = `-- name: ListPurchases :many
SELECT id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by FROM purchases
WHERE owner_id = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListPurchasesParams struct {
	OwnerID int32 `json:"owner_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListPurchases(ctx context.Context, arg ListPurchasesParams) ([]Purchase, error) {
	rows, err := q.db.QueryContext(ctx, listPurchases, arg.OwnerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Purchase
	for rows.Next() {
		var i Purchase
		if err := rows.Scan(
			&i.ID,
			&i.OwnerID,
			&i.UserID,
			&i.Number,
			&i.ApID,
			&i.Status,
			&i.Amount,
			&i.AmountPaid,
			&i.Date,
			&i.DueDate,
			&i.AdditionalInfo,
			&i.PeriodID,
			&i.ExpenseID,
			&i.DiscountID,
			&i.CreatedAt,
			&i.CreatedBy,
			&i.UpdatedAt,
			&i.UpdatedBy,
			&i.DeletedAt,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updatePurchase = `-- name: UpdatePurchase :one
UPDATE purchases
SET owner_id=$2,  
    user_id=$3, 
    "number"=$4, 
    ap_id=$5, 
    status=$6, 
    amount=$7, 
    amount_paid=$8, 
    "date"=$9, 
    due_date=$10, 
    additional_info=$11, 
    period_id=$12, 
    expense_id=$13, 
    discount_id=$14,
    updated_at=now(),
    updated_by=$15
WHERE id = $1
RETURNING id, owner_id, user_id, number, ap_id, status, amount, amount_paid, date, due_date, additional_info, period_id, expense_id, discount_id, created_at, created_by, updated_at, updated_by, deleted_at, deleted_by
`

type UpdatePurchaseParams struct {
	ID             int32                 `json:"id"`
	OwnerID        int32                 `json:"owner_id"`
	UserID         int32                 `json:"user_id"`
	Number         string                `json:"number"`
	ApID           int32                 `json:"ap_id"`
	Status         int16                 `json:"status"`
	Amount         string                `json:"amount"`
	AmountPaid     string                `json:"amount_paid"`
	Date           time.Time             `json:"date"`
	DueDate        time.Time             `json:"due_date"`
	AdditionalInfo pqtype.NullRawMessage `json:"additional_info"`
	PeriodID       sql.NullInt32         `json:"period_id"`
	ExpenseID      sql.NullInt32         `json:"expense_id"`
	DiscountID     sql.NullInt32         `json:"discount_id"`
	UpdatedBy      int32                 `json:"updated_by"`
}

func (q *Queries) UpdatePurchase(ctx context.Context, arg UpdatePurchaseParams) (Purchase, error) {
	row := q.db.QueryRowContext(ctx, updatePurchase,
		arg.ID,
		arg.OwnerID,
		arg.UserID,
		arg.Number,
		arg.ApID,
		arg.Status,
		arg.Amount,
		arg.AmountPaid,
		arg.Date,
		arg.DueDate,
		arg.AdditionalInfo,
		arg.PeriodID,
		arg.ExpenseID,
		arg.DiscountID,
		arg.UpdatedBy,
	)
	var i Purchase
	err := row.Scan(
		&i.ID,
		&i.OwnerID,
		&i.UserID,
		&i.Number,
		&i.ApID,
		&i.Status,
		&i.Amount,
		&i.AmountPaid,
		&i.Date,
		&i.DueDate,
		&i.AdditionalInfo,
		&i.PeriodID,
		&i.ExpenseID,
		&i.DiscountID,
		&i.CreatedAt,
		&i.CreatedBy,
		&i.UpdatedAt,
		&i.UpdatedBy,
		&i.DeletedAt,
		&i.DeletedBy,
	)
	return i, err
}
